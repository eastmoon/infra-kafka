# Kafka 設計概念

+ [Design](https://kafka.apache.org/documentation/#design)

由於設計概念諸多說明多為案例說明與理論解釋，本章不加翻譯，請參閱內文連結的官方文件。

## 動機 ( Motivation )

我們設計 Kafka 是為了能夠作為一個統一的平台來處理大型公司可能擁有的所有即時資料來源。為了做到這一點，我們必須仔細考慮相當廣泛的用例。

+ 它必須具有高吞吐量來支援大量事件流，例如即時日誌聚合。
+ 它需要妥善處理大量資料積累，以便能夠支援來自離線系統的定期資料載入。
+ 系統必須處理低延遲傳遞，以便能處理更傳統的訊息傳遞案例。

我們希望支援分區儲存、分散式部屬、即時處理數據；這激發了我們的分區化和消費者模式。

最後，在將流輸入到其他資料系統進行服務的情況下，我們知道該系統必須能夠在機器故障時保證容錯能力。

## 持久性 Persistence

**Don't fear the filesystem!**

Kafka 嚴重依賴檔案系統來儲存和快取訊息。人們普遍認為“磁碟很慢”，這使得人們懷疑持久結構能否提供有競爭力的性能。事實上，磁碟的速度比人們預期的要慢得多，也比人們預期的要快得多，這取決於如何使用，合理設計的磁碟結構其速度與網路傳輸無異。

關於磁碟效能的關鍵事實是，過去十年來，硬碟的吞吐量一直與磁碟搜尋的延遲有差異。典型案例中，在六個 7200rpm SATA 硬碟配置 RAID-5 磁碟陣列中，線性寫入的效能約為 600MB/秒，但隨機寫入的效能僅為 100k/秒左右，差異超過 6000 倍。硬碟的線性讀寫是所有模式中最可預測的，並且作業系統進行了大量最佳化。現代作業系統提供了預讀和後寫技術，可以預取大塊中的數據，從而提高實體寫入速度。有關此問題的進一步討論可以在 ACM Queue 文章中找到，他們實際上發現，在某些情況下，順序磁碟存取比隨機記憶體存取更快！

為了彌補效能差異，現代作業系統在使用主記憶體進行磁碟快取方面變得越來越積極。作業系統會很優先將所有可用記憶體轉移到磁碟緩存，並且在回收記憶體時幾乎不會造成效能損失。所有磁碟讀寫都將經過這個統一的快取。如果不使用直接 I/O，則無法輕易關閉此功能，因此即使進程維護資料的進程內緩存，該資料也可能會在 OS 緩存中，從而有效地將所有內容儲存兩次。

此外，我們是在 JVM 之上建構的，任何花過一些時間研究過 Java 記憶體使用情況的人都知道兩件事：

1、物件的記憶體開銷非常高，常常會使儲存的資料量增加一倍（甚至更糟）。
2、隨著堆內資料的增加，Java 垃圾收集變得越來越繁瑣和緩慢。

由於這些因素，使用文件系統並依賴頁面緩存，優於維護記憶體緩存或其他結構。如果您的磁碟使用情況有利於線性讀取，那麼預讀會在每次磁碟讀取時有效地使用有用的資料預先填充此快取。

這表明了一種非常簡單的設計：我們不會在記憶體中維護盡可能多的內容，然後在空間不足時驚慌地將其全部刷新到檔案系統中，而是將其反轉。所有資料都會立即寫入檔案系統上的持久性日誌，而不必刷新到磁碟。實際上這只是意味著它被轉移到核心的頁面快取中。

#### [Constant Time Suffices](https://kafka.apache.org/documentation/#design_constanttime)

Kafka 基於 BTree 設計當按資料結構，從而降低不必要的磁碟搜尋 ( Disk Seeks )，配合磁碟快取的設計從而將讀檔案的硬碟搜尋行為降到 O(1) 的速度；也因此，Kafka 可以提供長達一周或更長的訊息保存機制。

但需注意，這個理論成立的前提是磁碟搜尋不會被其他系統佔用，從而導致 IOPS 暴增，例如 Mongo 的記憶體索引回寫硬碟的設計。

## [效率 ( Efficiency )](https://kafka.apache.org/documentation/#maximizingefficiency)

Kafka 在上一節討論磁碟檔案存取效率，其目的在於消除不良的磁碟存取模式，在本節則解釋另外三個效率優化點：

+ 破碎的 I/O 操作
其解決方案是設計**訊息集 ( Message Set)**，傳輸與接收彙整後的資料，避免單筆的零碎資料充斥系統，也可確保寫入磁碟的事件內容佔用一整個連續區域。

+ 位元複製
其解決方式是利用 Linux 的 I/O 指令 ```sendfile```，避免檔案內容複製到系統記憶體、複製用戶記憶體、複製到通訊服務 ( 例如 Socket ) 記憶體、複製到網路卡記憶體，這四步繁瑣的位元複製流程。

+ 網路傳輸資料壓縮
期解決方式是支援 GZIP、Snappy、LZ4、ZStandard 壓縮協定，確保訊息集在網路傳輸時不會應為過大的內容與文件格式導致冗餘的位元傳輸。

## [The Producer](https://kafka.apache.org/documentation/#theproducer)

在 Kafka 的生產者，共有兩個設計概念：

+ 負載平衡 ( Load balancing )
傳遞訊息時，Kafka 會由目標的分區代理領導分配負責處理該訊息讀寫的請求，從而達到對任何 Kafka 節點發送請求都能有正確的節點負責回應。

+ 非同步發送 ( Asynchronous send )
考慮前述的**訊息集 ( Message Set)**概念，其訊息發送會達到容量 ( 64K )或時間 ( 10ms ) 閥值後才送出，而不是發送立刻送出的狀況。

## [The Consumer](https://kafka.apache.org/documentation/#theconsumer)

本節解釋 Kafka 的消費者讀取事件的設計概念與案例說明。

## [Message Delivery Semantics](https://kafka.apache.org/documentation/#semantics)

本節解釋 Kafka 如何利用 Commit 的概念達到至多一次 ( At most once )、至少一次 ( At least once )、確保一次 ( Exactly once ) 的傳輸設計；此節主要解釋傳輸資料遺失在 Kafka 是如何避免發生。

## [Replication](https://kafka.apache.org/documentation/#replication)

本節解釋 Kafka 副本 ( Replication ) 的設計邏輯、運作流程；此節主要解釋如何利用副本確保當異常發生時可以恢復內容或系統持續運作。

## [Log Compaction](https://kafka.apache.org/documentation/#compaction)

本節解釋 Kafka 日誌的用途案例與壓縮工作原理；此節主要解釋用於恢復系統資訊的日誌如何做資訊壓縮，避免日誌過大導致的效率問題。

## [Quotas](https://kafka.apache.org/documentation/#design_quotas)

本節解釋 Kafka 如何對客戶端執行資源配額，避免特定客戶端 ( 例如客戶端導致 DDoS 發生 ) 過量消耗效能，導致系統佔用 。
